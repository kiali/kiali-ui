/* tslint:disable */
/* eslint-disable */
/**
 * Kiali
 * Kiali project, observability for the Istio service mesh
 *
 * The version of the OpenAPI document: _
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Config } from '../models';
// @ts-ignore
import { InlineResponse400 } from '../models';
// @ts-ignore
import { InlineResponse500 } from '../models';
/**
 * GraphsApi - axios parameter creator
 * @export
 */
export const GraphsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * The backing JSON for an aggregate node detail graph. (supported graphTypes: app | versionedApp | workload)
     * @param {string} aggregate The aggregate name (label).
     * @param {string} aggregateValue The aggregate value (label value).
     * @param {string} namespace The namespace name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphAggregate: async (
      aggregate: string,
      aggregateValue: string,
      namespace: string,
      container?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'aggregate' is not null or undefined
      assertParamExists('graphAggregate', 'aggregate', aggregate);
      // verify required parameter 'aggregateValue' is not null or undefined
      assertParamExists('graphAggregate', 'aggregateValue', aggregateValue);
      // verify required parameter 'namespace' is not null or undefined
      assertParamExists('graphAggregate', 'namespace', namespace);
      const localVarPath = `/namespaces/{namespace}/aggregates/{aggregate}/{aggregateValue}/graph`
        .replace(`{${'aggregate'}}`, encodeURIComponent(String(aggregate)))
        .replace(`{${'aggregateValue'}}`, encodeURIComponent(String(aggregateValue)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (container !== undefined) {
        localVarQueryParameter['container'] = container;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The backing JSON for an aggregate node detail graph, specific to a service. (supported graphTypes: app | versionedApp | workload)
     * @param {string} aggregate The aggregate name (label).
     * @param {string} aggregateValue The aggregate value (label value).
     * @param {string} namespace The namespace name.
     * @param {string} service The service name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphAggregateByService: async (
      aggregate: string,
      aggregateValue: string,
      namespace: string,
      service: string,
      container?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'aggregate' is not null or undefined
      assertParamExists('graphAggregateByService', 'aggregate', aggregate);
      // verify required parameter 'aggregateValue' is not null or undefined
      assertParamExists('graphAggregateByService', 'aggregateValue', aggregateValue);
      // verify required parameter 'namespace' is not null or undefined
      assertParamExists('graphAggregateByService', 'namespace', namespace);
      // verify required parameter 'service' is not null or undefined
      assertParamExists('graphAggregateByService', 'service', service);
      const localVarPath = `/namespaces/{namespace}/aggregates/{aggregate}/{aggregateValue}/{service}/graph`
        .replace(`{${'aggregate'}}`, encodeURIComponent(String(aggregate)))
        .replace(`{${'aggregateValue'}}`, encodeURIComponent(String(aggregateValue)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)))
        .replace(`{${'service'}}`, encodeURIComponent(String(service)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (container !== undefined) {
        localVarQueryParameter['container'] = container;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The backing JSON for an app node detail graph. (supported graphTypes: app | versionedApp)
     * @param {string} app The app name (label value).
     * @param {string} namespace The namespace name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphApp: async (
      app: string,
      namespace: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'app' is not null or undefined
      assertParamExists('graphApp', 'app', app);
      // verify required parameter 'namespace' is not null or undefined
      assertParamExists('graphApp', 'namespace', namespace);
      const localVarPath = `/namespaces/{namespace}/applications/{app}/graph`
        .replace(`{${'app'}}`, encodeURIComponent(String(app)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (container !== undefined) {
        localVarQueryParameter['container'] = container;
      }

      if (appenders !== undefined) {
        localVarQueryParameter['appenders'] = appenders;
      }

      if (boxBy !== undefined) {
        localVarQueryParameter['boxBy'] = boxBy;
      }

      if (duration !== undefined) {
        localVarQueryParameter['duration'] = duration;
      }

      if (graphType !== undefined) {
        localVarQueryParameter['graphType'] = graphType;
      }

      if (includeIdleEdges !== undefined) {
        localVarQueryParameter['includeIdleEdges'] = includeIdleEdges;
      }

      if (injectServiceNodes !== undefined) {
        localVarQueryParameter['injectServiceNodes'] = injectServiceNodes;
      }

      if (queryTime !== undefined) {
        localVarQueryParameter['queryTime'] = queryTime;
      }

      if (rateGrpc !== undefined) {
        localVarQueryParameter['rateGrpc'] = rateGrpc;
      }

      if (rateHttp !== undefined) {
        localVarQueryParameter['rateHttp'] = rateHttp;
      }

      if (rateTcp !== undefined) {
        localVarQueryParameter['rateTcp'] = rateTcp;
      }

      if (responseTime !== undefined) {
        localVarQueryParameter['responseTime'] = responseTime;
      }

      if (throughput !== undefined) {
        localVarQueryParameter['throughput'] = throughput;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The backing JSON for a versioned app node detail graph. (supported graphTypes: app | versionedApp)
     * @param {string} app The app name (label value).
     * @param {string} version The app version (label value).
     * @param {string} namespace The namespace name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphAppVersion: async (
      app: string,
      version: string,
      namespace: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'app' is not null or undefined
      assertParamExists('graphAppVersion', 'app', app);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('graphAppVersion', 'version', version);
      // verify required parameter 'namespace' is not null or undefined
      assertParamExists('graphAppVersion', 'namespace', namespace);
      const localVarPath = `/namespaces/{namespace}/applications/{app}/versions/{version}/graph`
        .replace(`{${'app'}}`, encodeURIComponent(String(app)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (container !== undefined) {
        localVarQueryParameter['container'] = container;
      }

      if (appenders !== undefined) {
        localVarQueryParameter['appenders'] = appenders;
      }

      if (boxBy !== undefined) {
        localVarQueryParameter['boxBy'] = boxBy;
      }

      if (duration !== undefined) {
        localVarQueryParameter['duration'] = duration;
      }

      if (graphType !== undefined) {
        localVarQueryParameter['graphType'] = graphType;
      }

      if (includeIdleEdges !== undefined) {
        localVarQueryParameter['includeIdleEdges'] = includeIdleEdges;
      }

      if (injectServiceNodes !== undefined) {
        localVarQueryParameter['injectServiceNodes'] = injectServiceNodes;
      }

      if (queryTime !== undefined) {
        localVarQueryParameter['queryTime'] = queryTime;
      }

      if (rateGrpc !== undefined) {
        localVarQueryParameter['rateGrpc'] = rateGrpc;
      }

      if (rateHttp !== undefined) {
        localVarQueryParameter['rateHttp'] = rateHttp;
      }

      if (rateTcp !== undefined) {
        localVarQueryParameter['rateTcp'] = rateTcp;
      }

      if (responseTime !== undefined) {
        localVarQueryParameter['responseTime'] = responseTime;
      }

      if (throughput !== undefined) {
        localVarQueryParameter['throughput'] = throughput;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary The backing JSON for a namespaces graph.
     * @param {string} namespaces Comma-separated list of namespaces to include in the graph. The namespaces must be accessible to the client.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphNamespaces: async (
      namespaces: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'namespaces' is not null or undefined
      assertParamExists('graphNamespaces', 'namespaces', namespaces);
      const localVarPath = `/namespaces/graph`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (appenders !== undefined) {
        localVarQueryParameter['appenders'] = appenders;
      }

      if (boxBy !== undefined) {
        localVarQueryParameter['boxBy'] = boxBy;
      }

      if (duration !== undefined) {
        localVarQueryParameter['duration'] = duration;
      }

      if (graphType !== undefined) {
        localVarQueryParameter['graphType'] = graphType;
      }

      if (includeIdleEdges !== undefined) {
        localVarQueryParameter['includeIdleEdges'] = includeIdleEdges;
      }

      if (injectServiceNodes !== undefined) {
        localVarQueryParameter['injectServiceNodes'] = injectServiceNodes;
      }

      if (namespaces !== undefined) {
        localVarQueryParameter['namespaces'] = namespaces;
      }

      if (queryTime !== undefined) {
        localVarQueryParameter['queryTime'] = queryTime;
      }

      if (rateGrpc !== undefined) {
        localVarQueryParameter['rateGrpc'] = rateGrpc;
      }

      if (rateHttp !== undefined) {
        localVarQueryParameter['rateHttp'] = rateHttp;
      }

      if (rateTcp !== undefined) {
        localVarQueryParameter['rateTcp'] = rateTcp;
      }

      if (responseTime !== undefined) {
        localVarQueryParameter['responseTime'] = responseTime;
      }

      if (throughput !== undefined) {
        localVarQueryParameter['throughput'] = throughput;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary The backing JSON for a service node detail graph.
     * @param {string} namespace The namespace name.
     * @param {string} service The service name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphService: async (
      namespace: string,
      service: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'namespace' is not null or undefined
      assertParamExists('graphService', 'namespace', namespace);
      // verify required parameter 'service' is not null or undefined
      assertParamExists('graphService', 'service', service);
      const localVarPath = `/namespaces/{namespace}/services/{service}/graph`
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)))
        .replace(`{${'service'}}`, encodeURIComponent(String(service)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (container !== undefined) {
        localVarQueryParameter['container'] = container;
      }

      if (appenders !== undefined) {
        localVarQueryParameter['appenders'] = appenders;
      }

      if (boxBy !== undefined) {
        localVarQueryParameter['boxBy'] = boxBy;
      }

      if (duration !== undefined) {
        localVarQueryParameter['duration'] = duration;
      }

      if (graphType !== undefined) {
        localVarQueryParameter['graphType'] = graphType;
      }

      if (queryTime !== undefined) {
        localVarQueryParameter['queryTime'] = queryTime;
      }

      if (rateGrpc !== undefined) {
        localVarQueryParameter['rateGrpc'] = rateGrpc;
      }

      if (rateHttp !== undefined) {
        localVarQueryParameter['rateHttp'] = rateHttp;
      }

      if (rateTcp !== undefined) {
        localVarQueryParameter['rateTcp'] = rateTcp;
      }

      if (responseTime !== undefined) {
        localVarQueryParameter['responseTime'] = responseTime;
      }

      if (throughput !== undefined) {
        localVarQueryParameter['throughput'] = throughput;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary The backing JSON for a workload node detail graph.
     * @param {string} namespace The namespace name.
     * @param {string} workload The workload name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphWorkload: async (
      namespace: string,
      workload: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'namespace' is not null or undefined
      assertParamExists('graphWorkload', 'namespace', namespace);
      // verify required parameter 'workload' is not null or undefined
      assertParamExists('graphWorkload', 'workload', workload);
      const localVarPath = `/namespaces/{namespace}/workloads/{workload}/graph`
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)))
        .replace(`{${'workload'}}`, encodeURIComponent(String(workload)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (container !== undefined) {
        localVarQueryParameter['container'] = container;
      }

      if (appenders !== undefined) {
        localVarQueryParameter['appenders'] = appenders;
      }

      if (boxBy !== undefined) {
        localVarQueryParameter['boxBy'] = boxBy;
      }

      if (duration !== undefined) {
        localVarQueryParameter['duration'] = duration;
      }

      if (graphType !== undefined) {
        localVarQueryParameter['graphType'] = graphType;
      }

      if (includeIdleEdges !== undefined) {
        localVarQueryParameter['includeIdleEdges'] = includeIdleEdges;
      }

      if (injectServiceNodes !== undefined) {
        localVarQueryParameter['injectServiceNodes'] = injectServiceNodes;
      }

      if (queryTime !== undefined) {
        localVarQueryParameter['queryTime'] = queryTime;
      }

      if (rateGrpc !== undefined) {
        localVarQueryParameter['rateGrpc'] = rateGrpc;
      }

      if (rateHttp !== undefined) {
        localVarQueryParameter['rateHttp'] = rateHttp;
      }

      if (rateTcp !== undefined) {
        localVarQueryParameter['rateTcp'] = rateTcp;
      }

      if (responseTime !== undefined) {
        localVarQueryParameter['responseTime'] = responseTime;
      }

      if (throughput !== undefined) {
        localVarQueryParameter['throughput'] = throughput;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * GraphsApi - functional programming interface
 * @export
 */
export const GraphsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GraphsApiAxiosParamCreator(configuration);
  return {
    /**
     * The backing JSON for an aggregate node detail graph. (supported graphTypes: app | versionedApp | workload)
     * @param {string} aggregate The aggregate name (label).
     * @param {string} aggregateValue The aggregate value (label value).
     * @param {string} namespace The namespace name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async graphAggregate(
      aggregate: string,
      aggregateValue: string,
      namespace: string,
      container?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.graphAggregate(
        aggregate,
        aggregateValue,
        namespace,
        container,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * The backing JSON for an aggregate node detail graph, specific to a service. (supported graphTypes: app | versionedApp | workload)
     * @param {string} aggregate The aggregate name (label).
     * @param {string} aggregateValue The aggregate value (label value).
     * @param {string} namespace The namespace name.
     * @param {string} service The service name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async graphAggregateByService(
      aggregate: string,
      aggregateValue: string,
      namespace: string,
      service: string,
      container?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.graphAggregateByService(
        aggregate,
        aggregateValue,
        namespace,
        service,
        container,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * The backing JSON for an app node detail graph. (supported graphTypes: app | versionedApp)
     * @param {string} app The app name (label value).
     * @param {string} namespace The namespace name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async graphApp(
      app: string,
      namespace: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.graphApp(
        app,
        namespace,
        container,
        appenders,
        boxBy,
        duration,
        graphType,
        includeIdleEdges,
        injectServiceNodes,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * The backing JSON for a versioned app node detail graph. (supported graphTypes: app | versionedApp)
     * @param {string} app The app name (label value).
     * @param {string} version The app version (label value).
     * @param {string} namespace The namespace name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async graphAppVersion(
      app: string,
      version: string,
      namespace: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.graphAppVersion(
        app,
        version,
        namespace,
        container,
        appenders,
        boxBy,
        duration,
        graphType,
        includeIdleEdges,
        injectServiceNodes,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary The backing JSON for a namespaces graph.
     * @param {string} namespaces Comma-separated list of namespaces to include in the graph. The namespaces must be accessible to the client.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async graphNamespaces(
      namespaces: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.graphNamespaces(
        namespaces,
        appenders,
        boxBy,
        duration,
        graphType,
        includeIdleEdges,
        injectServiceNodes,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary The backing JSON for a service node detail graph.
     * @param {string} namespace The namespace name.
     * @param {string} service The service name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async graphService(
      namespace: string,
      service: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.graphService(
        namespace,
        service,
        container,
        appenders,
        boxBy,
        duration,
        graphType,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary The backing JSON for a workload node detail graph.
     * @param {string} namespace The namespace name.
     * @param {string} workload The workload name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async graphWorkload(
      namespace: string,
      workload: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.graphWorkload(
        namespace,
        workload,
        container,
        appenders,
        boxBy,
        duration,
        graphType,
        includeIdleEdges,
        injectServiceNodes,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    }
  };
};

/**
 * GraphsApi - factory interface
 * @export
 */
export const GraphsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = GraphsApiFp(configuration);
  return {
    /**
     * The backing JSON for an aggregate node detail graph. (supported graphTypes: app | versionedApp | workload)
     * @param {string} aggregate The aggregate name (label).
     * @param {string} aggregateValue The aggregate value (label value).
     * @param {string} namespace The namespace name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphAggregate(
      aggregate: string,
      aggregateValue: string,
      namespace: string,
      container?: string,
      options?: any
    ): AxiosPromise<Config> {
      return localVarFp
        .graphAggregate(aggregate, aggregateValue, namespace, container, options)
        .then(request => request(axios, basePath));
    },
    /**
     * The backing JSON for an aggregate node detail graph, specific to a service. (supported graphTypes: app | versionedApp | workload)
     * @param {string} aggregate The aggregate name (label).
     * @param {string} aggregateValue The aggregate value (label value).
     * @param {string} namespace The namespace name.
     * @param {string} service The service name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphAggregateByService(
      aggregate: string,
      aggregateValue: string,
      namespace: string,
      service: string,
      container?: string,
      options?: any
    ): AxiosPromise<Config> {
      return localVarFp
        .graphAggregateByService(aggregate, aggregateValue, namespace, service, container, options)
        .then(request => request(axios, basePath));
    },
    /**
     * The backing JSON for an app node detail graph. (supported graphTypes: app | versionedApp)
     * @param {string} app The app name (label value).
     * @param {string} namespace The namespace name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphApp(
      app: string,
      namespace: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): AxiosPromise<Config> {
      return localVarFp
        .graphApp(
          app,
          namespace,
          container,
          appenders,
          boxBy,
          duration,
          graphType,
          includeIdleEdges,
          injectServiceNodes,
          queryTime,
          rateGrpc,
          rateHttp,
          rateTcp,
          responseTime,
          throughput,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     * The backing JSON for a versioned app node detail graph. (supported graphTypes: app | versionedApp)
     * @param {string} app The app name (label value).
     * @param {string} version The app version (label value).
     * @param {string} namespace The namespace name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphAppVersion(
      app: string,
      version: string,
      namespace: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): AxiosPromise<Config> {
      return localVarFp
        .graphAppVersion(
          app,
          version,
          namespace,
          container,
          appenders,
          boxBy,
          duration,
          graphType,
          includeIdleEdges,
          injectServiceNodes,
          queryTime,
          rateGrpc,
          rateHttp,
          rateTcp,
          responseTime,
          throughput,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary The backing JSON for a namespaces graph.
     * @param {string} namespaces Comma-separated list of namespaces to include in the graph. The namespaces must be accessible to the client.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphNamespaces(
      namespaces: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): AxiosPromise<Config> {
      return localVarFp
        .graphNamespaces(
          namespaces,
          appenders,
          boxBy,
          duration,
          graphType,
          includeIdleEdges,
          injectServiceNodes,
          queryTime,
          rateGrpc,
          rateHttp,
          rateTcp,
          responseTime,
          throughput,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary The backing JSON for a service node detail graph.
     * @param {string} namespace The namespace name.
     * @param {string} service The service name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphService(
      namespace: string,
      service: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): AxiosPromise<Config> {
      return localVarFp
        .graphService(
          namespace,
          service,
          container,
          appenders,
          boxBy,
          duration,
          graphType,
          queryTime,
          rateGrpc,
          rateHttp,
          rateTcp,
          responseTime,
          throughput,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary The backing JSON for a workload node detail graph.
     * @param {string} namespace The namespace name.
     * @param {string} workload The workload name.
     * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
     * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
     * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
     * @param {string} [duration] Query time-range duration (Golang string duration).
     * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
     * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
     * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
     * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
     * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
     * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
     * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
     * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
     * @param {string} [throughput] Used only with throughput appender. One of: request | response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    graphWorkload(
      namespace: string,
      workload: string,
      container?: string,
      appenders?: string,
      boxBy?: string,
      duration?: string,
      graphType?: string,
      includeIdleEdges?: string,
      injectServiceNodes?: string,
      queryTime?: string,
      rateGrpc?: string,
      rateHttp?: string,
      rateTcp?: string,
      responseTime?: string,
      throughput?: string,
      options?: any
    ): AxiosPromise<Config> {
      return localVarFp
        .graphWorkload(
          namespace,
          workload,
          container,
          appenders,
          boxBy,
          duration,
          graphType,
          includeIdleEdges,
          injectServiceNodes,
          queryTime,
          rateGrpc,
          rateHttp,
          rateTcp,
          responseTime,
          throughput,
          options
        )
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * GraphsApi - object-oriented interface
 * @export
 * @class GraphsApi
 * @extends {BaseAPI}
 */
export class GraphsApi extends BaseAPI {
  /**
   * The backing JSON for an aggregate node detail graph. (supported graphTypes: app | versionedApp | workload)
   * @param {string} aggregate The aggregate name (label).
   * @param {string} aggregateValue The aggregate value (label value).
   * @param {string} namespace The namespace name.
   * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public graphAggregate(
    aggregate: string,
    aggregateValue: string,
    namespace: string,
    container?: string,
    options?: any
  ) {
    return GraphsApiFp(this.configuration)
      .graphAggregate(aggregate, aggregateValue, namespace, container, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * The backing JSON for an aggregate node detail graph, specific to a service. (supported graphTypes: app | versionedApp | workload)
   * @param {string} aggregate The aggregate name (label).
   * @param {string} aggregateValue The aggregate value (label value).
   * @param {string} namespace The namespace name.
   * @param {string} service The service name.
   * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public graphAggregateByService(
    aggregate: string,
    aggregateValue: string,
    namespace: string,
    service: string,
    container?: string,
    options?: any
  ) {
    return GraphsApiFp(this.configuration)
      .graphAggregateByService(aggregate, aggregateValue, namespace, service, container, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * The backing JSON for an app node detail graph. (supported graphTypes: app | versionedApp)
   * @param {string} app The app name (label value).
   * @param {string} namespace The namespace name.
   * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
   * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
   * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
   * @param {string} [duration] Query time-range duration (Golang string duration).
   * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
   * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
   * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
   * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
   * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
   * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
   * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
   * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
   * @param {string} [throughput] Used only with throughput appender. One of: request | response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public graphApp(
    app: string,
    namespace: string,
    container?: string,
    appenders?: string,
    boxBy?: string,
    duration?: string,
    graphType?: string,
    includeIdleEdges?: string,
    injectServiceNodes?: string,
    queryTime?: string,
    rateGrpc?: string,
    rateHttp?: string,
    rateTcp?: string,
    responseTime?: string,
    throughput?: string,
    options?: any
  ) {
    return GraphsApiFp(this.configuration)
      .graphApp(
        app,
        namespace,
        container,
        appenders,
        boxBy,
        duration,
        graphType,
        includeIdleEdges,
        injectServiceNodes,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * The backing JSON for a versioned app node detail graph. (supported graphTypes: app | versionedApp)
   * @param {string} app The app name (label value).
   * @param {string} version The app version (label value).
   * @param {string} namespace The namespace name.
   * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
   * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
   * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
   * @param {string} [duration] Query time-range duration (Golang string duration).
   * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
   * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
   * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
   * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
   * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
   * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
   * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
   * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
   * @param {string} [throughput] Used only with throughput appender. One of: request | response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public graphAppVersion(
    app: string,
    version: string,
    namespace: string,
    container?: string,
    appenders?: string,
    boxBy?: string,
    duration?: string,
    graphType?: string,
    includeIdleEdges?: string,
    injectServiceNodes?: string,
    queryTime?: string,
    rateGrpc?: string,
    rateHttp?: string,
    rateTcp?: string,
    responseTime?: string,
    throughput?: string,
    options?: any
  ) {
    return GraphsApiFp(this.configuration)
      .graphAppVersion(
        app,
        version,
        namespace,
        container,
        appenders,
        boxBy,
        duration,
        graphType,
        includeIdleEdges,
        injectServiceNodes,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary The backing JSON for a namespaces graph.
   * @param {string} namespaces Comma-separated list of namespaces to include in the graph. The namespaces must be accessible to the client.
   * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
   * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
   * @param {string} [duration] Query time-range duration (Golang string duration).
   * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
   * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
   * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
   * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
   * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
   * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
   * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
   * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
   * @param {string} [throughput] Used only with throughput appender. One of: request | response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public graphNamespaces(
    namespaces: string,
    appenders?: string,
    boxBy?: string,
    duration?: string,
    graphType?: string,
    includeIdleEdges?: string,
    injectServiceNodes?: string,
    queryTime?: string,
    rateGrpc?: string,
    rateHttp?: string,
    rateTcp?: string,
    responseTime?: string,
    throughput?: string,
    options?: any
  ) {
    return GraphsApiFp(this.configuration)
      .graphNamespaces(
        namespaces,
        appenders,
        boxBy,
        duration,
        graphType,
        includeIdleEdges,
        injectServiceNodes,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary The backing JSON for a service node detail graph.
   * @param {string} namespace The namespace name.
   * @param {string} service The service name.
   * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
   * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
   * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
   * @param {string} [duration] Query time-range duration (Golang string duration).
   * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
   * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
   * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
   * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
   * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
   * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
   * @param {string} [throughput] Used only with throughput appender. One of: request | response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public graphService(
    namespace: string,
    service: string,
    container?: string,
    appenders?: string,
    boxBy?: string,
    duration?: string,
    graphType?: string,
    queryTime?: string,
    rateGrpc?: string,
    rateHttp?: string,
    rateTcp?: string,
    responseTime?: string,
    throughput?: string,
    options?: any
  ) {
    return GraphsApiFp(this.configuration)
      .graphService(
        namespace,
        service,
        container,
        appenders,
        boxBy,
        duration,
        graphType,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary The backing JSON for a workload node detail graph.
   * @param {string} namespace The namespace name.
   * @param {string} workload The workload name.
   * @param {string} [container] The cluster name. If not supplied queries/results will not be constrained by cluster.
   * @param {string} [appenders] Comma-separated list of Appenders to run. Available appenders: [aggregateNode, deadNode, healthConfig, idleNode, istio, responseTime, securityPolicy, serviceEntry, sidecarsCheck, throughput].
   * @param {string} [boxBy] Comma-separated list of desired node boxing. Available boxings: [app, cluster, namespace, none].
   * @param {string} [duration] Query time-range duration (Golang string duration).
   * @param {string} [graphType] Graph type. Available graph types: [app, service, versionedApp, workload].
   * @param {string} [includeIdleEdges] Flag for including edges that have no request traffic for the time period.
   * @param {string} [injectServiceNodes] Flag for injecting the requested service node between source and destination nodes.
   * @param {string} [queryTime] Unix time (seconds) for query such that time range is [queryTime-duration..queryTime]. Default is now.
   * @param {string} [rateGrpc] How to calculate gRPC traffic rate. One of: none | received (i.e. response_messages) | requests | sent (i.e. request_messages) | total (i.e. sent+received).
   * @param {string} [rateHttp] How to calculate HTTP traffic rate. One of: none | requests.
   * @param {string} [rateTcp] How to calculate TCP traffic rate. One of: none | received (i.e. received_bytes) | sent (i.e. sent_bytes) | total (i.e. sent+received).
   * @param {string} [responseTime] Used only with responseTime appender. One of: avg | 50 | 95 | 99.
   * @param {string} [throughput] Used only with throughput appender. One of: request | response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphsApi
   */
  public graphWorkload(
    namespace: string,
    workload: string,
    container?: string,
    appenders?: string,
    boxBy?: string,
    duration?: string,
    graphType?: string,
    includeIdleEdges?: string,
    injectServiceNodes?: string,
    queryTime?: string,
    rateGrpc?: string,
    rateHttp?: string,
    rateTcp?: string,
    responseTime?: string,
    throughput?: string,
    options?: any
  ) {
    return GraphsApiFp(this.configuration)
      .graphWorkload(
        namespace,
        workload,
        container,
        appenders,
        boxBy,
        duration,
        graphType,
        includeIdleEdges,
        injectServiceNodes,
        queryTime,
        rateGrpc,
        rateHttp,
        rateTcp,
        responseTime,
        throughput,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }
}
